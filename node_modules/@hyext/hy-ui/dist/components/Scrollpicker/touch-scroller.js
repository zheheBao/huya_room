function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

import { View, PanResponder, Animated } from 'react-native';
import React from 'react';
var scrollerStyles = {
  overflow: 'hidden',
  userSelect: 'none'
};
export var TouchScroller = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(TouchScroller, _React$Component);

  function TouchScroller(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.AnimateOffsetY = new Animated.Value(0);
    _this.animated = false;

    _this.touchStart = function (e) {
      _this.lastDistance = _this.getPointY(e);
      return true;
    };

    _this.touchMove = function (e) {
      var offestY = _this.state.offestY;

      var currlocationY = _this.getPointY(e);

      var offset = currlocationY - _this.lastDistance;
      _this.lastDistance = currlocationY;

      _this.setState({
        offestY: offestY + offset
      });
    };

    _this.touchEnd = function () {
      var onScrollEndDrag = _this.props.onScrollEndDrag;
      var offestY = _this.state.offestY;
      onScrollEndDrag && onScrollEndDrag({
        nativeEvent: {
          contentOffset: {
            y: -offestY
          }
        }
      });
    };

    _this.state = {
      offestY: 0
    };
    return _this;
  }

  var _proto = TouchScroller.prototype;

  _proto.componentWillMount = function componentWillMount() {
    this.panResponder = PanResponder.create({
      onStartShouldSetPanResponder: this.touchStart,
      onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder(_) {
        return false;
      },
      // onPanResponderGrant: this.pressStart,
      onPanResponderMove: this.touchMove,
      onPanResponderRelease: this.touchEnd,
      onPanResponderTerminationRequest: function onPanResponderTerminationRequest(_) {
        return false;
      },
      onPanResponderTerminate: this.touchEnd
    });
  };

  _proto.scrollWithAnimate = function scrollWithAnimate(y) {
    var _this2 = this;

    var offestY = this.state.offestY;
    this.AnimateOffsetY.setValue(offestY);
    this.animated = true;
    setTimeout(function () {
      Animated.timing(_this2.AnimateOffsetY, {
        toValue: y,
        duration: 5000
      }).start(function () {
        _this2.animated = false;
      });
    });
  };

  _proto.scrollTo = function scrollTo(opts) {
    var y = opts.y,
        animated = opts.animated;
    var offestY = -y; // 滚动跟拖拽的偏移距离 刚好相反
    // if (animated) {
    //   this.scrollWithAnimate(offestY)
    // }

    this.setState({
      offestY: offestY
    });
  };

  _proto.getPointY = function getPointY(e) {
    var nativeEvent = e.nativeEvent;
    return nativeEvent.touches[0].pageY;
  };

  _proto.getStyle = function getStyle() {
    var offestY = this.state.offestY;
    var translateY = this.animated ? this.AnimateOffsetY : offestY;
    var style = {
      transform: [{
        translateY: translateY
      }]
    };
    return style;
  };

  _proto.render = function render() {
    var _this$props = this.props,
        style = _this$props.style,
        contentContainerStyle = _this$props.contentContainerStyle,
        children = _this$props.children;
    return /*#__PURE__*/React.createElement(View, {
      style: [scrollerStyles, style]
    }, /*#__PURE__*/React.createElement(Animated.View, _extends({
      style: [contentContainerStyle, this.getStyle()]
    }, this.panResponder.panHandlers), children));
  };

  return TouchScroller;
}(React.Component);
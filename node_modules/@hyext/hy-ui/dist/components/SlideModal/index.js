function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

import React from "react";
import { View, TouchableOpacity, StyleSheet, Animated } from "react-native";
import { Modal } from "../Modal";
import { SlideAnimated } from "../../common/animations";
import variables from "../../common/styles/variables";
export var slideModalStyles = StyleSheet.create({
  container: {
    position: "absolute",
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    flexDirection: "row",
    alignItems: "flex-start",
    justifyContent: "center",
    overflow: "hidden"
  },
  backdrop: {
    position: "absolute",
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    backgroundColor: variables.hyFillBackdrop
  },
  content: {
    position: "absolute",
    overflow: "hidden"
  }
});
export var SlideModal = /*#__PURE__*/function (_Modal) {
  _inheritsLoose(SlideModal, _Modal);

  function SlideModal(props) {
    var _this;

    _this = _Modal.call(this, props) || this;

    _this.handleRootLayout = function (e) {
      var _this$state = _this.state,
          viewportWidth = _this$state.viewportWidth,
          viewportHeight = _this$state.viewportHeight;
      var _e$nativeEvent$layout = e.nativeEvent.layout,
          width = _e$nativeEvent$layout.width,
          height = _e$nativeEvent$layout.height; // 如果发现视口宽高和根容器不一样的时候 使用根容器的宽高

      if (viewportWidth !== width || viewportHeight !== height) {
        _this.setState({
          viewportWidth: width,
          viewportHeight: height
        });
      }
    };

    _this.handleLayout = function (e) {
      var _this$state2 = _this.state,
          directionType = _this$state2.directionType,
          direction = _this$state2.direction;
      var _e$nativeEvent$layout2 = e.nativeEvent.layout,
          width = _e$nativeEvent$layout2.width,
          height = _e$nativeEvent$layout2.height;
      var ret = [];
      directionType.forEach(function (directionTypeItem) {
        if (directionTypeItem === "vertical") {
          ret.push({
            size: direction.indexOf("up") !== -1 ? height : -height,
            directionTypeItem: directionTypeItem
          });
        }

        if (directionTypeItem === "horizontal") {
          ret.push({
            size: direction.indexOf("right") !== -1 ? -width : width,
            directionTypeItem: directionTypeItem
          });
        }
      });

      _this.animated.reset(ret);
    };

    return _this;
  } // 重写 Modal 父类 init 方法


  var _proto = SlideModal.prototype;

  _proto.init = function init(props, syncTag) {
    var directions = [["up"], ["up", "left"], ["up", "right"], ["down"], ["down", "left"], ["down", "right"], ["left"], ["right"]];
    var direction = typeof props.direction === "string" ? [props.direction] : props.direction;
    var propsDirectionValid = directions.some(function (directionItem) {
      var str1 = directionItem.join();
      var str2 = directionItem.reverse().join();
      var str3 = direction.join();

      if (str3 === str1 || str3 === str2) {
        return true;
      }
    });

    if (!propsDirectionValid) {
      throw new TypeError("direction \u53C2\u6570 " + props.direction + " \u4E3A\u65E0\u6548\u503C");
    }

    var directionType = [];

    if (direction.indexOf("up") !== -1 || direction.indexOf("down") !== -1) {
      directionType.push("vertical");
    }

    if (direction.indexOf("left") !== -1 || direction.indexOf("right") !== -1) {
      directionType.push("horizontal");
    }

    var align;

    if (direction.length === 1) {
      if (directionType.indexOf("vertical") !== -1) {
        align = props.align === "left" || props.align === "right" ? props.align : "right";
      } else {
        align = props.align === "up" || props.align === "down" ? props.align : "down";
      }
    }

    var directionWithAlign = [];

    if (direction.length === 2) {
      directionWithAlign = direction;
    } else {
      directionWithAlign = [].concat(direction, [align]);
    }

    var data = {
      directionType: directionType,
      direction: direction,
      align: align,
      directionWithAlign: directionWithAlign,
      viewportHeight: props.viewportHeight,
      viewportWidth: props.viewportWidth
    };
    this.animated = new SlideAnimated({
      // duration: 1000
      directionType: data.directionType
    });

    if (syncTag) {
      this.state = _objectSpread(_objectSpread({}, this.state), data);
    } else {
      this.setState(_objectSpread(_objectSpread({}, this.state), data));
    }
  };

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.direction !== this.props.direction || nextProps.align !== this.props.align || nextProps.offsetX !== this.props.offsetX || nextProps.offsetY !== this.props.offsetY || nextProps.viewportWidth !== this.props.viewportWidth || nextProps.viewportHeight !== this.props.viewportHeight) {
      this.init(nextProps, false);
    }
  };

  _proto.open = function open(c) {
    return Modal.prototype.open.call(this, c);
  };

  _proto.getRects = function getRects() {
    var _this$props = this.props,
        offsetX = _this$props.offsetX,
        offsetY = _this$props.offsetY;
    var _this$state3 = this.state,
        directionWithAlign = _this$state3.directionWithAlign,
        viewportWidth = _this$state3.viewportWidth,
        viewportHeight = _this$state3.viewportHeight;
    var defaultRect = {
      top: null,
      bottom: null,
      left: null,
      right: null
    };

    var contentContainerRect = _objectSpread({}, defaultRect);

    var contentRect = _objectSpread({}, defaultRect);

    var contentClockwise2Rect = _objectSpread({
      backgroundColor: "red"
    }, defaultRect);

    var contentClockwise1Rect = _objectSpread({
      backgroundColor: "blue"
    }, defaultRect);

    var contentClockwise3Rect = _objectSpread({
      backgroundColor: "green"
    }, defaultRect); // 如果offsetY被指定则使用它本身，没有被指定这使用state的viewportHeight作为默认偏置


    var finalOffsetY = offsetY > 0 ? offsetY : viewportHeight;

    if (directionWithAlign.indexOf("up") !== -1) {
      contentContainerRect.top = 0;
      contentContainerRect.bottom = viewportHeight - finalOffsetY;
      contentClockwise2Rect.top = finalOffsetY;
      contentClockwise2Rect.bottom = 0;
      contentClockwise1Rect.left = offsetX;
      contentClockwise1Rect.right = 0;
      contentClockwise3Rect.left = 0;
      contentClockwise3Rect.right = viewportWidth - offsetX;
      contentRect.bottom = 0;
    }

    if (directionWithAlign.indexOf("down") !== -1) {
      contentContainerRect.top = finalOffsetY;
      contentContainerRect.bottom = 0;
      contentClockwise2Rect.top = 0;
      contentClockwise2Rect.bottom = viewportHeight - finalOffsetY;
      contentClockwise1Rect.left = 0;
      contentClockwise1Rect.right = viewportWidth - offsetX;
      contentClockwise3Rect.left = offsetX;
      contentClockwise3Rect.right = 0;
      contentRect.top = 0;
    }

    if (directionWithAlign.indexOf("right") !== -1) {
      contentContainerRect.left = offsetX;
      contentContainerRect.right = 0;
      contentClockwise2Rect.left = 0;
      contentClockwise2Rect.right = viewportWidth - offsetX;
      contentClockwise1Rect.top = finalOffsetY;
      contentClockwise1Rect.bottom = 0;
      contentClockwise3Rect.top = 0;
      contentClockwise3Rect.bottom = viewportHeight - finalOffsetY;
      contentRect.left = 0;
    }

    if (directionWithAlign.indexOf("left") !== -1) {
      contentContainerRect.left = 0;
      contentContainerRect.right = viewportWidth - offsetX;
      contentClockwise2Rect.left = offsetX;
      contentClockwise2Rect.right = 0;
      contentClockwise1Rect.top = 0;
      contentClockwise1Rect.bottom = viewportHeight - finalOffsetY;
      contentClockwise3Rect.top = finalOffsetY;
      contentClockwise3Rect.bottom = 0;
      contentRect.right = 0;
    }

    return {
      contentContainerRect: contentContainerRect,
      contentRect: contentRect,
      contentClockwise1Rect: contentClockwise1Rect,
      contentClockwise2Rect: contentClockwise2Rect,
      contentClockwise3Rect: contentClockwise3Rect
    };
  };

  _proto.getFullScreenPatch = function getFullScreenPatch() {
    var _this2 = this;

    var _this$props2 = this.props,
        cancelable = _this$props2.cancelable,
        backdropColor = _this$props2.backdropColor,
        fullScreenPatch = _this$props2.fullScreenPatch;

    if (fullScreenPatch.length !== 3) {
      throw new TypeError("fullScreenPatch \u53C2\u6570 " + fullScreenPatch + " \u4E3A\u65E0\u6548\u503C");
    }

    var rects = this.getRects();
    var tmp = fullScreenPatch.map(function (patchItem, patchIndex) {
      if (patchItem) {
        return "contentClockwise" + (patchIndex + 1) + "Rect";
      } else {
        return "";
      }
    }).filter(function (tmpItem) {
      return tmpItem;
    }).map(function (key) {
      return {
        key: key,
        cancelable: cancelable,
        closeFn: _this2.close.bind(_this2, "backdrop"),
        rect: _objectSpread(_objectSpread({}, rects[key]), {}, {
          backgroundColor: backdropColor
        })
      };
    });
    return tmp;
  };

  _proto.getContent = function getContent(inner) {
    var _this3 = this;

    var tmp = inner == null ? this.props.children : inner;

    var _this$getRects = this.getRects(),
        contentContainerRect = _this$getRects.contentContainerRect,
        contentRect = _this$getRects.contentRect;

    var fullScreenPatch = this.getFullScreenPatch();
    return /*#__PURE__*/React.createElement(View, {
      style: [{
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        // viewportWidth
        bottom: 0 // viewportHeight

      }, this.props.styles.root],
      collapsable: false,
      onLayout: this.handleRootLayout,
      pointerEvents: "box-none"
    }, fullScreenPatch.map(function (patchItem, patchIndex) {
      return /*#__PURE__*/React.createElement(TouchableOpacity, {
        key: patchIndex,
        activeOpacity: 1,
        style: _objectSpread({
          position: "absolute"
        }, patchItem.rect),
        onPress: function onPress() {
          if (patchItem.cancelable) {
            patchItem.closeFn();
          }
        }
      });
    }), /*#__PURE__*/React.createElement(View, {
      collapsable: false,
      style: [slideModalStyles.container, _objectSpread({}, contentContainerRect), this.props.styles.container]
    }, /*#__PURE__*/React.createElement(TouchableOpacity, {
      testID: "backdrop",
      style: [slideModalStyles.backdrop, {
        backgroundColor: this.props.backdropColor
      }, this.props.styles.backdrop],
      activeOpacity: 1,
      onPress: function onPress() {
        _this3.handlePressBackdrop();
      }
    }), /*#__PURE__*/React.createElement(Animated.View, {
      style: [slideModalStyles.content, _objectSpread({}, contentRect), {
        transform: [{
          translateY: this.animated.getState().translateY
        }, {
          translateX: this.animated.getState().translateX
        }],
        opacity: this.animated.getState().opacity
      }, this.props.styles.content],
      onLayout: this.handleLayout
    }, tmp || null)));
  };

  return SlideModal;
}(Modal);
SlideModal.defaultProps = _objectSpread(_objectSpread({}, Modal.defaultProps), {}, {
  styles: {},
  cancelable: false,
  offsetX: 0,
  offsetY: 0,
  direction: "up",
  align: "right",
  fullScreenPatch: [false, false, false]
});
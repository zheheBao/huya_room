export function range(length) {
  var ret = [];

  for (var i = 0; i < length; i++) {
    ret.push(i);
  }

  return ret;
}
export function hexToRgb(hex) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}
export function isLeapYear(year) {
  year = parseInt(year, 10);

  if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {
    return true;
  } else {
    return false;
  }
}
export function convert2Digit(i) {
  i = Number(i);

  if (i >= 0 && i < 10) {
    i = '0' + i;
  } else {
    i = '' + i;
  }

  return i;
}
export function convert2Number(value) {
  value = String(value);
  value = value.length === 2 && value[0] === '0' ? value[1] : value;
  return parseInt(value, 10);
}
export function replaceProperty(obj, rawKey, replaceKey) {
  var rawValue = obj[rawKey];
  obj[replaceKey] = rawValue;
  delete obj[rawKey];
}
export function looseClone(obj) {
  return Object.assign({}, obj);
}
export function hasHttp(src) {
  return /^http/.test(src);
}
export function ensureHttps(link) {
  return link.replace(/^http:/, 'https:');
}
export function processImageComSrc(src) {
  var source = src; // 传入一个网络路径

  if (typeof source === 'string' && hasHttp(source)) {
    source = {
      uri: source
    };
  } else {// do something
  }

  return source;
}
export function mergeStyle(styleProps, additionProps) {
  if (styleProps === void 0) {
    styleProps = {};
  }

  if (Array.isArray(styleProps)) {
    styleProps = styleProps.concat();
    styleProps.unshift(additionProps);
  } else if (typeof styleProps === 'object' && styleProps !== null) {
    styleProps = Object.assign({}, additionProps, styleProps);
  }

  return styleProps;
}
export function formatComponentName(componentName) {
  var RE = /(.+)_$/;

  if (RE.test(componentName)) {
    return componentName.replace(RE, '$1');
  }

  return componentName;
}
export function formatComponentMapping(componentMapping) {
  var newMapping = {};
  Object.keys(componentMapping).forEach(function (componentName) {
    newMapping[formatComponentName(componentName)] = componentMapping[componentName];
  });
  return newMapping;
}
export function once(cb) {
  var flag = false;
  return function () {
    if (flag) return;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    cb.apply(this, args);
    flag = true;
  };
}